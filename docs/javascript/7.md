---
title: 深入理解 JavaScript 中的垃圾回收机制及其原理
---

# 深入理解 JavaScript 中的垃圾回收机制及其原理

在 JavaScript 这门广泛应用的编程语言中，垃圾回收机制是一个至关重要的特性，它在幕后默默工作，确保程序的内存使用保持在合理的范围内，防止内存泄漏并提高程序的性能。本文将深入探讨 JavaScript 中的垃圾回收机制及其原理，带你揭开这个神秘而又关键的技术背后的面纱。

## 一、为什么需要垃圾回收机制？

在计算机程序中，内存是一种有限的资源。当我们创建变量、对象和函数等时，它们会占用内存空间。如果不进行有效的内存管理，程序可能会耗尽内存，导致性能下降甚至崩溃。

JavaScript 是一种自动内存管理的语言，这意味着开发者不需要手动分配和释放内存。垃圾回收机制负责自动检测不再被使用的内存空间，并将其回收，以便可以重新分配给新的对象和数据。

例如，当我们在函数中创建一个局部变量，在函数执行完毕后，如果这个变量不再被引用，那么它所占用的内存就可以被回收。垃圾回收机制使得开发者可以专注于编写业务逻辑，而不必过多地担心内存管理的细节。

## 二、JavaScript 的内存管理基础

在深入了解垃圾回收机制之前，我们先来了解一下 JavaScript 的内存管理基础。

### （一）内存分配

#### 值类型（原始类型）

JavaScript 中的值类型包括number、string、boolean、null和undefined等。
当我们创建一个值类型的变量时，JavaScript 会在栈（stack）上为其分配内存空间。栈是一种后进先出（LIFO）的数据结构，分配和释放内存的速度非常快。

例如：

```js
const num = 10
const str = 'Hello'
const bool = true
```

在上述代码中，变量num、str和bool分别在栈上分配了内存空间，存储它们的值。

#### 引用类型

JavaScript 中的引用类型包括object、array、function等。

当我们创建一个引用类型的变量时，JavaScript 会在堆（heap）上为其分配内存空间，并在栈上存储一个指向堆内存的引用。

例如：

```js
const obj = { name: 'John', age: 30 }
const arr = [1, 2, 3]
const func = function () { console.log('Hello') }
```

在上述代码中，变量obj、arr和func分别在堆上分配了内存空间，存储对象、数组和函数的实际内容。而在栈上存储了指向这些堆内存的引用。

### （二）内存使用

**变量的生命周期**

变量的生命周期是指变量从创建到不再被使用的过程。

在 JavaScript 中，变量的生命周期取决于其作用域。全局变量的生命周期贯穿整个程序的运行过程，而局部变量的生命周期则在其所在的函数执行完毕后结束。

例如：

```js
function example() {
  const localVar = 'Local variable'
  console.log(localVar)
}
example()
// localVar 在函数执行完毕后不再被使用
```

在上述代码中，变量localVar是一个局部变量，它的生命周期在函数example执行完毕后结束。

#### 对象的引用

对象在 JavaScript 中是通过引用来传递和操作的。

当我们将一个对象赋值给一个变量时，实际上是将对象的引用存储在变量中。多个变量可以引用同一个对象，对其中一个变量的操作会影响到其他引用该对象的变量。

例如：

```js
const obj1 = { name: 'John' }
const obj2 = obj1
obj2.name = 'Jane'
console.log(obj1.name) // "Jane"
```

在上述代码中，变量obj1和obj2都引用了同一个对象。当我们修改obj2的属性时，obj1也会受到影响，因为它们指向同一个内存地址。

## 三、垃圾回收的基本原理

JavaScript 中的垃圾回收机制主要基于可达性的概念。简单来说，垃圾回收器会从一些被称为 “根”（root）的对象开始，沿着对象之间的引用关系进行遍历，找到所有可达的对象。那些不可达的对象就被认为是垃圾，可以被回收。

### （一）根对象

#### 全局对象

在浏览器环境中，全局对象是window对象。在 Node.js 环境中，全局对象是global对象。

全局对象始终可达，因为它们在程序的整个生命周期中都存在。

#### 执行上下文栈

当函数被调用时，会创建一个新的执行上下文，并将其压入执行上下文栈。执行上下文包含了函数的局部变量、参数和内部函数等。

只要执行上下文栈中存在一个执行上下文，其中的局部变量就可能是可达的。

#### 垃圾回收器内部的一些数据结构

垃圾回收器可能会维护一些内部的数据结构，用于跟踪对象的引用关系。这些数据结构中的对象也被视为根对象。

### （二）可达性分析

#### 标记阶段

垃圾回收器首先会从根对象开始，遍历所有可达的对象，并将它们标记为 “可达”。

这个过程可以使用深度优先搜索（DFS）或广度优先搜索（BFS）等算法来实现。

#### 清除阶段

在标记阶段完成后，垃圾回收器会扫描整个堆内存，找到所有未被标记为 “可达” 的对象，并将它们的内存空间回收。

回收的内存可以被重新分配给新的对象。

例如，考虑以下代码：

```js
function example() {
  const obj1 = { name: 'John' }
  const obj2 = { name: 'Jane' }
  obj1.next = obj2
  obj2.prev = obj1
  return obj1
}
const result = example()
// 函数执行完毕后，obj2 不再被直接引用，但由于 obj1 和 obj2 之间的相互引用，它们仍然可达
```

在上述代码中，函数example创建了两个对象obj1和obj2，并使它们相互引用。当函数执行完毕后，局部变量obj1和obj2不再被直接引用。然而，由于它们之间的相互引用，垃圾回收器在进行可达性分析时，仍然会将它们标记为可达，不会被回收。

## 四、垃圾回收的算法

JavaScript 中主要有两种垃圾回收算法：标记清除（Mark and Sweep）和引用计数（Reference Counting）。

### （一）标记清除算法

#### 工作原理

如前所述，标记清除算法分为标记阶段和清除阶段。

在标记阶段，垃圾回收器从根对象开始，遍历所有可达的对象，并将它们标记为 “可达”。

在清除阶段，垃圾回收器扫描整个堆内存，找到所有未被标记为 “可达” 的对象，并将它们的内存空间回收。

#### 优点

可以有效地处理循环引用的情况。

不会因为引用计数的错误导致内存泄漏。

#### 缺点

垃圾回收过程可能会导致程序暂停，影响性能。

回收后的内存空间可能会出现碎片化的情况，需要进行内存整理。

例如，考虑以下代码：

```js
function example() {
  const obj1 = { name: 'John' }
  const obj2 = { name: 'Jane' }
  obj1.next = obj2
  obj2.prev = obj1
  return obj1
}
const result = example()
// 一段时间后，没有其他地方引用 result，垃圾回收器可以回收 obj1 和 obj2 占用的内存
```

在上述代码中，函数example创建了两个对象obj1和obj2，并使它们相互引用。当函数执行完毕后，局部变量obj1和obj2不再被直接引用。但是，由于它们之间的相互引用，引用计数算法无法回收它们的内存。而标记清除算法可以正确地识别这种情况，并在没有其他地方引用这两个对象时，将它们的内存回收。

### （二）引用计数算法

#### 工作原理

引用计数算法通过跟踪对象的引用数量来确定对象是否可以被回收。

当一个对象被创建时，它的引用计数为 1。当有其他变量引用这个对象时，它的引用计数加 1。当一个引用被删除时，它的引用计数减 1。当一个对象的引用计数为 0 时，它就可以被回收。

#### 优点

可以立即回收不再被引用的对象，减少内存占用。

不需要进行全局的标记和清除操作，不会导致程序暂停。

#### 缺点

无法处理循环引用的情况。

引用计数的维护需要额外的开销，可能会影响性能。

例如，考虑以下代码：

```js
function example() {
  const obj1 = { name: 'John' }
  const obj2 = { name: 'Jane' }
  obj1.next = obj2
  obj2.prev = obj1
  return obj1
}
const result = example()
// 由于 obj1 和 obj2 之间的相互引用，它们的引用计数始终不为 0，无法被回收
```

在上述代码中，函数example创建了两个对象obj1和obj2，并使它们相互引用。由于它们的引用计数始终不为 0，引用计数算法无法回收它们的内存，导致内存泄漏。

## 五、垃圾回收的优化

为了减少垃圾回收对程序性能的影响，JavaScript 引擎采用了一些优化技术。

### （一）分代回收

#### 概念

分代回收是一种基于对象生命周期的垃圾回收策略。

JavaScript 中的对象可以分为新生代和老生代两个代。新生代中的对象通常是生命周期较短的对象，而老生代中的对象通常是生命周期较长的对象。

#### 工作原理

**新生代回收**

新生代中的对象通常是通过复制算法进行回收的。

当新生代中的对象被创建时，它们会被分配到一个称为 “From 空间” 的区域。当 “From 空间” 满了时，垃圾回收器会将其中的存活对象复制到一个称为 “To 空间” 的区域，然后清空 “From 空间”。

在下一次新生代回收时，“From 空间” 和 “To 空间” 的角色会互换。

**老生代回收**

老生代中的对象通常是通过标记清除算法或标记整理算法进行回收的。

当老生代中的对象数量达到一定阈值时，垃圾回收器会触发一次老生代回收。

标记清除算法会标记所有可达的对象，并回收不可达的对象。标记整理算法会在标记清除算法的基础上，对内存空间进行整理，减少碎片化。

**优点**

可以针对不同生命周期的对象采用不同的回收策略，提高垃圾回收的效率。

减少了垃圾回收对程序性能的影响。

### （二）增量回收

#### 概念

增量回收是一种将垃圾回收过程分成多个小步骤执行的技术。

这样可以避免在一次垃圾回收过程中长时间暂停程序的执行，提高程序的响应性。

#### 工作原理

垃圾回收器会在程序执行的过程中，定期地执行一小部分垃圾回收任务。

例如，垃圾回收器可以在每次函数调用之后，执行一小部分标记或清除操作。

这样可以将垃圾回收的时间分散到程序的执行过程中，减少对程序性能的影响。

#### 优点

提高了程序的响应性，减少了垃圾回收对程序性能的影响。

可以在程序运行的同时进行垃圾回收，提高了垃圾回收的效率。

### （三）延迟回收

#### 概念

延迟回收是一种将垃圾回收的时间延迟到内存使用达到一定阈值时才进行的技术。

这样可以避免在程序运行的早期进行不必要的垃圾回收，提高程序的性能。

#### 工作原理

垃圾回收器会监控程序的内存使用情况。当内存使用达到一定阈值时，垃圾回收器会触发一次垃圾回收。

例如，垃圾回收器可以在内存使用达到 80% 时，触发一次垃圾回收。

#### 优点

可以避免在程序运行的早期进行不必要的垃圾回收，提高程序的性能。

可以根据程序的实际内存使用情况，自动调整垃圾回收的时间，提高垃圾回收的效率。

## 六、如何优化代码以减少垃圾回收的影响？

虽然垃圾回收机制在很大程度上减轻了开发者的内存管理负担，但我们仍然可以通过一些优化措施来减少垃圾回收对程序性能的影响。

### （一）避免不必要的对象创建

#### 尽量复用对象

如果可能的话，尽量复用已经存在的对象，而不是每次都创建新的对象。

例如，在循环中，如果需要创建一个临时对象，可以考虑在循环外部创建一个对象，并在循环内部复用它。

#### 使用对象池

对象池是一种管理对象创建和销毁的技术。它可以预先创建一定数量的对象，并在需要时从对象池中获取对象，使用完毕后将对象归还到对象池中，而不是直接销毁对象。

例如，在游戏开发中，可以使用对象池来管理游戏中的敌人、子弹等对象，避免频繁地创建和销毁对象。

### （二）避免循环引用

#### 及时解除不必要的引用

如果两个对象之间存在循环引用，并且在某个时刻不再需要其中一个对象时，应该及时解除对该对象的引用，以便垃圾回收器可以回收它的内存。

例如：

```js
function example() {
  const obj1 = { name: 'John' }
  const obj2 = { name: 'Jane' }
  obj1.next = obj2
  obj2.prev = obj1
  // 在不需要 obj2 时，解除对它的引用
  obj1.next = null
  obj2.prev = null
  return obj1
}
```

在上述代码中，当不再需要obj2时，我们及时解除了obj1对obj2的引用，以及obj2对obj1的引用，避免了循环引用的问题。

#### 使用弱引用

JavaScript 中提供了WeakMap和WeakSet两种弱引用数据结构。它们不会阻止垃圾回收器回收它们所引用的对象。

例如：

```js
const weakMap = new WeakMap()
let obj = { name: 'John' }
weakMap.set(obj, 'Some value')
// 当 obj 不再被其他地方引用时，垃圾回收器可以回收它的内存
obj = null
```

在上述代码中，我们使用WeakMap来存储一个对象和一个值。当对象obj不再被其他地方引用时，垃圾回收器可以回收它的内存，而不会因为WeakMap的引用而阻止回收。

### （三）优化数据结构的使用

#### 避免使用大的数组或对象

如果可能的话，尽量避免使用大的数组或对象，因为它们会占用大量的内存，增加垃圾回收的压力。

可以考虑使用更高效的数据结构，如Map、Set等，它们可以更有效地管理数据，减少内存占用。

#### 及时清理不再使用的数据

如果一个数组或对象中存储了大量的数据，并且在某个时刻不再需要其中的一部分数据时，应该及时清理这些数据，以便释放内存。

例如：

```js
const arr = [1, 2, 3, 4, 5]
// 在不需要某些元素时，删除它们
arr.splice(2, 2)
```

在上述代码中，我们使用splice方法删除了数组arr中的两个元素。这样可以及时释放这两个元素所占用的内存，减少垃圾回收的压力。

## 七、总结

JavaScript 中的垃圾回收机制是一个复杂而又关键的技术，它在幕后默默地工作，确保程序的内存使用保持在合理的范围内。通过了解垃圾回收机制的原理和算法，我们可以更好地理解 JavaScript 的内存管理，并通过优化代码来减少垃圾回收对程序性能的影响。

在实际开发中，我们应该避免不必要的对象创建、及时解除循环引用、优化数据结构的使用等，以提高程序的性能和稳定性。同时，我们也应该关注 JavaScript 引擎的发展，了解最新的垃圾回收优化技术，以便更好地利用它们来提高我们的开发效率。
