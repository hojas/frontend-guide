---
title: JavaScript 中 ==、=== 和 Object.is() 有什么区别？
---

# JavaScript 中 ==、=== 和 Object.is() 有什么区别？

在 JavaScript 中，比较操作符是我们经常会用到的工具。其中，==、===和Object.is()这三个比较方式在不同的场景下有着不同的表现，理解它们之间的区别对于编写准确、可靠的 JavaScript 代码至关重要。

## 一、==（相等运算符）

==是相等运算符，它在进行比较时会进行类型转换。

### 1. 基本规则

如果两个操作数的类型相同，那么比较的方式与严格相等运算符===类似。例如，5 == 5结果为true。

如果两个操作数的类型不同，JavaScript 会尝试进行类型转换，然后再进行比较。例如，5 == '5'结果为true，这里将字符串'5'转换为数字 5 后进行比较。

### 2. 特殊情况

null和undefined比较特殊，null == undefined结果为true，但null、undefined与其他任何值比较都不会自动转换类型，除非其中一方是Object类型。例如，null == 0结果为false。

NaN与任何值（包括它自己）使用==比较都返回false。例如，NaN == NaN结果为false。

## 二、===（严格相等运算符）

===是严格相等运算符，它在进行比较时不会进行类型转换，只有在两个操作数的类型和值都完全相同时才返回true。

### 1. 基本规则

如果两个操作数的类型不同，直接返回false。例如，5 === '5'结果为false。

如果两个操作数的类型相同，按照以下规则进行比较：

对于数字类型，比较它们的值是否相等。例如，5 === 5结果为true。

对于字符串类型，比较它们的字符序列是否完全相同。例如，'hello' === 'hello'结果为true。

对于布尔类型，只有当两个布尔值都为true或都为false时才返回true。例如，true === true结果为true，true === false结果为false。

对于对象类型，比较它们是否指向同一个对象。例如，两个不同的对象即使属性和值完全相同，使用===比较也会返回false。

### 2. 特殊情况

NaN与任何值（包括它自己）使用===比较都返回false，与==一致。例如，NaN === NaN结果为false。

+0和-0在严格相等比较中是不同的，但在某些数学运算中它们可能被视为相等。例如，+0 === -0结果为true。

## 三、Object.is()

Object.is()方法判断两个值是否为同一值。它的行为与===基本相似，但在处理一些特殊情况时有不同。

### 1. 基本规则

和===一样，如果两个操作数的类型不同，直接返回false。

对于相同类型的操作数，比较方式与===类似，但在处理NaN和+0、-0时有区别。

### 2. 特殊情况

Object.is(NaN, NaN)结果为true，与==和===不同，这更符合数学上对NaN的定义，即NaN不等于任何值，包括它自己，但Object.is()认为两个NaN是同一值。

Object.is(+0, -0)结果为false，明确区分了正零和负零，而==和===将它们视为相等。

## 四、实际应用中的考虑

### 1. 代码的准确性

当需要进行严格的比较，确保类型和值都完全相同时，应该使用===或Object.is()。例如，在判断用户输入的密码是否与存储的密码完全一致时，使用严格相等可以避免由于类型转换导致的错误判断。

如果不确定操作数的类型，并且希望进行灵活的比较，可以考虑使用==，但要注意类型转换可能带来的意外结果。例如，在接收用户输入的数字时，如果用户输入的是字符串形式的数字，使用==可能会导致意外的结果，而使用Number(input) === expectedNumber可以确保进行正确的比较。

### 2. 性能考虑

一般来说，==和===的性能差异不大，但在某些情况下，由于==需要进行类型转换，可能会稍微慢一些。然而，这种性能差异通常非常微小，在大多数应用中可以忽略不计。

### 3. 代码的可读性

使用===和Object.is()可以使代码更具可读性，因为它们的行为更加明确。其他开发者在阅读代码时，可以更容易地理解你的比较意图，减少由于隐含的类型转换带来的困惑。

## 五、总结

在 JavaScript 中，==、===和Object.is()都用于比较值，但它们在比较方式和处理特殊情况上有所不同。了解这些区别可以帮助我们在编写代码时做出正确的选择，确保代码的准确性、可读性和性能。在实际应用中，我们应该根据具体的需求选择合适的比较方式，避免由于不当的比较导致的错误。
