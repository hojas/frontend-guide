---
title: HTTP/2
---

# HTTP/2

HTTP/2 兼容 HTTP1.1 并且相对于 HTTP/1.1 改善了 HTTP 的性能，于 2015 年 5 月以 [RFC 7540](https://datatracker.ietf.org/doc/html/rfc7540) 正式发表。

## HTTP/1.1 的性能问题

- **延迟难以下降**，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；
- **并发连接有限**，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；
- **队头阻塞问题**，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；
- **HTTP 头部巨大且重复**，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；
- **不支持服务器推送消息**，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。

## 头部压缩

HTTP 协议的报文是由「Header + Body」构成的，对于 Body 部分，HTTP/1.1 协议可以使用头字段 「Content-Encoding」指定 Body 的压缩方式，比如用 gzip 压缩，这样可以节约带宽，但报文中的另外一部分 Header，是没有针对它的优化手段。

HTTP/2 开发了 HPACK 算法，HPACK 算法主要包含三个组成部分：

- 静态字典
- 动态字典
- Huffman 编码（压缩算法）

客户端和服务器两端都会建立和维护「字典」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，可达到 50%~90% 的高压缩率。

## 二进制帧

HTTP/2 将 HTTP/1.1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。

HTTP/2 把响应报文划分成了两类帧（Frame），HEADERS（首部）和 DATA（消息负载），也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。

帧头（Frame Header）很小，只有 9 个字节，帧开头的前 3 个字节表示帧数据（Frame Payload）的长度。

## 并发传输

HTTP/2 通过多个 Stream 复用一条 TCP 连接，达到并发的效果，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。

## 服务器主动推送资源

客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 PUSH_PROMISE 帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。
